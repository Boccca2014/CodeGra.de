#!/usr/bin/env python3
# SPDX-License-Identifier: AGPL-3.0-only

import os
import csv
import sys
import json
from collections import OrderedDict

WARNING = """.. warning::

  Do not edit this enum as it is automatically generated by
  "{filename}".""".format(filename=os.path.basename(__file__))
INDENT_WARNING = '\n'.join(
    '' if l == ' ' * 4 else l
    for l in ('\n    '.join(WARNING.split('\n'))).split('\n')
)

HEADER = """\"\"\"This file contains all permissions used by CodeGrade in a python enum.

{warning}

SPDX-License-Identifier: AGPL-3.0-only
\"\"\"
# pylint: skip-file
# flake8: noqa=E501
# yapf: disable

import enum
import typing as t

from . import exceptions

AnyPermission = t.TypeVar(  # pylint: disable=invalid-name
    'AnyPermission', 'GlobalPermission', 'CoursePermission'
)
__T = t.TypeVar('__T', bound='BasePermission')  # pylint: disable=invalid-name

_PermissionValue = t.NamedTuple('_PermissionValue', [('item', object), ('default_value', bool)])


def init_app(app: t.Any, skip_perm_check: bool) -> None:
    "\"\"Initialize flask app
    "\"\"
    if skip_perm_check:
        return
    database_permissions_sanity_check(app)  # pragma: no cover


def database_permissions_sanity_check(app: t.Any) -> None:
    "\"\"Check if database has all the correct permissions.
    "\"\"
    from . import models
    with app.app_context():
        import structlog

        logger = structlog.get_logger()

        from_enum = set((p, p.value.default_value) for p in list(GlobalPermission) + list(CoursePermission))
        from_database = set((p.value, p.default_value) for p in models.db.session.query(models.Permission).all())
        if from_enum != from_database:  # pragma: no cover
            logger.error('Not all permissions were found in the database', difference=from_enum ^ from_database)
            assert from_enum == from_database


CoursePermMap = t.NewType('CoursePermMap', t.Mapping[str, bool])
GlobalPermMap = t.NewType('GlobalPermMap', t.Mapping[str, bool])


class BasePermission(enum.Enum):
    "\"\"The base of a permission.

    Do not use this class to get permissions, as it has none!
    "\"\"

    @staticmethod
    def create_map(mapping: t.Any) -> t.Any:
        \"\"\"Create a map.
        \"\"\"
        return {{k.name: v for k, v in mapping.items()}}

    @classmethod
    def get_by_name(cls: t.Type['__T'], name: str) -> '__T':
        \"\"\"Get a permission by name.

        :param name: The name of the permission.
        :returns: The found permission.

        :raises exceptions.APIException: When the permission was not found.
        \"\"\"
        try:
            return cls[name]
        except KeyError:
            raise exceptions.APIException(
                ('The requested permission '
                 '"{{}}" does not exist').format(name),
                'The requested course permission was not found',
                exceptions.APICodes.OBJECT_NOT_FOUND, 404
            )

    def __to_json__(self) -> str:  # pragma: no cover
        \"\"\"Convert a permission to json.

        :returns: The name of the permission.
        \"\"\"
        return self.name


    def __lt__(self, other: 'BasePermission') -> bool:  # pragma: no cover
        return self.value < other.value  # pylint: disable=comparison-with-callable


@enum.unique
class GlobalPermission(BasePermission):
    \"\"\"The global permissions used by CodeGrade.

    {indent_warning}

""".format(
    filename=os.path.basename(__file__),
    warning=WARNING,
    indent_warning=INDENT_WARNING,
)


def genereate_value_str(index: object, perm_name: str, default_value: bool):
    return f'    {perm_name} = _PermissionValue(item={index}, default_value={default_value})\n'


def main() -> None:
    out_path = os.path.abspath(
        os.path.join(
            os.path.dirname(__file__), '..', 'psef', 'permissions.py'
        )
    )
    perms_path = os.path.join(
        os.path.dirname(__file__), '..', 'seed_data', 'permissions.json'
    )

    print(f'Writing to "{out_path}"', end=' ... ')
    sys.stdout.flush()

    with open(perms_path, 'r') as f_perms, open(out_path, 'w') as out:
        perms = json.load(f_perms, object_pairs_hook=OrderedDict)
        global_perms = OrderedDict(
            (n, d) for n, d in perms.items() if not d['course_permission']
        )
        course_perms = OrderedDict(
            (n, d) for n, d in perms.items() if d['course_permission']
        )

        generate_csv(global_perms, 'global')
        generate_csv(course_perms, 'course')

        del perms

        out.write(HEADER)
        for perm_name, perm_data in global_perms.items():
            out.write(
                f'    :ivar {perm_name}: {perm_data["long_description"]}\n'
            )
        out.write('    """\n')
        out.write(
            """
    @staticmethod
    def create_map(mapping: t.Mapping['GlobalPermission', bool]) -> GlobalPermMap:
        return BasePermission.create_map(mapping)

"""
        )

        for i, (perm_name, perm_data) in enumerate(global_perms.items()):
            out.write(
                genereate_value_str(i, perm_name, perm_data['default_value'])
            )
        out.write(
            """

@enum.unique
class CoursePermission(BasePermission):
    \"\"\"The course permissions used by CodeGrade.

    {}

""".format(INDENT_WARNING)
        )
        for perm_name, perm_data in course_perms.items():
            out.write(
                f'    :ivar {perm_name}: {perm_data["long_description"]}\n'
            )
        out.write('    """\n')

        out.write(
            """
    @staticmethod
    def create_map(mapping: t.Mapping['CoursePermission', bool]) -> CoursePermMap:
        return BasePermission.create_map(mapping)

"""
        )
        for i, (perm_name, perm_data) in enumerate(course_perms.items()):
            out.write(
                genereate_value_str(i, perm_name, perm_data['default_value'])
            )

        out.write("\n# yapf: enable\n")

    print('done!')


def generate_csv(perms, name) -> None:
    with open(
        os.path.join(
            os.path.dirname(__file__), '..', 'docs', f'{name}_permissions.csv'
        ), 'w'
    ) as f:
        writer = csv.writer(f)
        writer.writerow(['Name', 'Description'])
        writer.writerows(
            [
                (
                    '**{}**{}'.format(
                        v["short_description"],
                        ' \\*' if v['default_value'] else ''
                    ), v['long_description']
                ) for v in perms.values()
            ]
        )


if __name__ == '__main__':
    main()
