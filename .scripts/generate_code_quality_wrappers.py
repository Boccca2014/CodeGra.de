#!/usr/bin/env python3
# SPDX-License-Identifier: AGPL-3.0-only

import os
import re
import sys
import glob
import typing as t
import dataclasses

WARNING = """
Do not edit this enum as it is automatically generated by
"{filename}".""".format(filename=os.path.basename(__file__))

HEADER = """This file contains all wrapper scripts used by CodeGrade in
the "Code Quality" AutoTest step."""

PY_HEADER = """\"\"\"{header}

.. warning::

  {warning}

SPDX-License-Identifier: AGPL-3.0-only
\"\"\"
# pylint: skip-file
# flake8: noqa=E501
# yapf: disable

import typing as t
import dataclasses

import cg_enum


@dataclasses.dataclass
class _CodeQualityWrapper:
    name: str
    source: t.Optional[str]
    executable: t.Optional[str]


""".format(
    header=HEADER,
    warning='\n  '.join(WARNING.split('\n')),
)

TS_HEADER = """/**
{header}

{warning}

SPDX-License-Identifier: AGPL-3.0-only
*/
/* eslint-disable */

export class CodeQualityWrapper {{
    constructor(public key: string, public name: string) {{
        Object.freeze(this);
    }}
}}

export type CodeQualityWrapperName = keyof typeof codeQualityWrappers;

""".format(
    header=HEADER,
    warning=WARNING,
)


@dataclasses.dataclass
class WrapperInfo:
    key: str
    name: str
    source: str

    @classmethod
    def from_path(cls, path: str) -> 'WrapperInfo':
        source = os.path.basename(path)
        key, _ = os.path.splitext(source)
        # Remove leading cg_
        name = key[3:]
        return cls(key=key, name=name, source=source)

    @classmethod
    def make_list(cls, paths: t.Sequence[str]) -> t.List['WrapperInfo']:
        return sorted(
            (cls.from_path(p) for p in paths),
            key=lambda info: info.name,
        )


def render_py_enum_entry(info: WrapperInfo) -> str:
    source = os.path.basename(info.source)

    return f"{info.key} = _CodeQualityWrapper(name='{info.name}', source='{source}', executable='{info.key}')"


def render_py_enum(scripts: t.Iterable[WrapperInfo]) -> str:
    return """class CodeQualityWrapper(cg_enum.CGEnum):
    custom = _CodeQualityWrapper(name='custom', source=None, executable=None)
    {}
""".format(
    '\n    '.join(render_py_enum_entry(s) for s in scripts),
)


def render_ts_enum_entry(info: WrapperInfo) -> str:
    return f"{info.key}: new CodeQualityWrapper('{info.key}', '{info.name}')"


def render_ts_enum(scripts: t.Iterable[WrapperInfo]) -> str:
    return """export const codeQualityWrappers = Object.freeze({{
    {},
    custom: new CodeQualityWrapper('custom', 'custom'),
}} as const);
""".format(
    ',\n    '.join(render_ts_enum_entry(s) for s in scripts),
)


def main() -> None:
    base_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
    psef_dir = os.path.join(base_dir, 'psef')

    wrapper_dir = os.path.join(psef_dir, 'auto_test', 'code_quality_wrappers')
    wrapper_scripts = WrapperInfo.make_list(
        glob.glob(os.path.join(wrapper_dir, 'cg_*.py'))
    )

    py_out_path = os.path.join(wrapper_dir, '__init__.py')
    ts_out_path = os.path.join(base_dir, 'src', 'code_quality_wrappers.ts')

    print(f'Writing to "{py_out_path}"', end=' ... \n')
    sys.stdout.flush()

    with open(py_out_path, 'w') as out:
        out.write(PY_HEADER)
        out.write(render_py_enum(wrapper_scripts))

    print(f'Writing to "{ts_out_path}"', end=' ... \n')
    sys.stdout.flush()

    with open(ts_out_path, 'w') as out:
        out.write(TS_HEADER)
        out.write(render_ts_enum(wrapper_scripts))

    print('done!')


if __name__ == '__main__':
    main()
